# DARS TEST

## Технические данные

| Окружение      | Версия |
| --------- | -----|
| PHP  | 8.1.16 |
| Сервер     |  Apache/2.4.54 (Debian) |
| База данных      |    MySQL 5.7 |
| Yii Version      |   2.0.47 |
| Yii Template      |   Advanced |

## Тестовое задание

Описание задания находится в файле TASK.md

## Копирование настроек окружения

Копируем файл настройки проекта:

`$ cp .env.dist .env`

Копируем файл настройки Docker:

`$ cp docker-compose.yml.dist docker-compose.yml`

Проект готов для выгрузки на сервер. Файл **.htaccess** находится в настройках среды **environments/prod**
Фронт будет доступен по адресу: **site.ru**
RESTful API по адресу: **api.site.ru**

## Настройка окружения

После копирования файлов необходимо настроить файлы **.env** и **docker-compose.yml** под свое окружение. Настройки рабочего сервера см выше. Все инструкции ниже будут подразумевать дефолтные настройки.

Важно:
- В папке **developer/mysql/mysql-dump** должен находиться только один файл с расширением **.sql** для каждой базы. Например, если вы используете тестовую БД и рабочую, в папке могут находиться два файла, которые предполагают выгрузку двух разных БД.
- Папка **developer/mysql/db** должна быть пустой или вообще отсутствовать, т.к. именно туда будет автоматически установлена база данных после запуска контейнеров. Если при запуске контейнеров папка **db** не пустая, дампы БД залиты не будут.
- Если не используете докер, дамп БД берите с папки **developer/mysql/mysql-dump**.

Устанавливаем настройки окружения yii:

`$ php init`

Запускаем контейнеры Docker:

`$ docker-compose up -d`

Устанавливаем пакеты зависимостей:

`$ composer install`

Иногда после команды composer install выпадают множественные ошибки, например, из-за отсутствия необходимых библиотек PHP. В этом случае либо устраняем все ошибки, либо устанавливаем пакеты проекта без учета зависимостей (но помним, что такая установка может приводить к ошибкам на страницах проекта):

`$ composer install --ignore-platform-reqs`

+ Фронт доступен по адресу: http://localhost:8000
+ RESTful API доступно по адресу: http://localhost:8001
+ phpMyAdmin доступен по адресу: http://localhost:8080
  * **Логин:** root
  * **Пароль:** root

Не стал использовать файлы Nginx и Apache, а соответственно и человекоподобные URL, чтобы не было проблем с запуском проекта в докере.

+ В системе создано два пользователя: суперадминистратор и клиент.
  * **Суперадминистратор:**
  * Логин - admin
  * Пароль - admin333
  * **Клиент:**
  * Логин - client
  * Пароль - client123

После запуска контейнеров Docker накатится пустая БД для проверки CRUD, т.к. это часть задания (Docker заполняет только необходимые **users** и **RBAC**). После проверки работоспособности CRUD необходимо выполнить миграции для заполнения БД тестовыми данными и дальнейшнего тестирования RESTful API.

Входим в контейнер:

`$ docker exec -ti <ID_или_название_контейтера> bash`

Запускаем миграции:

`$ php yii migrate`

Документация RESTful API находится в корне проекта в файле **RESTful.md**

## Тестирование
После запуска контейнеров Docker, дамп БД из **developer/mysql/mysql-dump/darsdb_test.sql** автоматически подготавливается к тестам.

Входим в контейнер:

`$ docker exec -ti <ID_или_название_контейтера> bash`

Запускаем тесты:

`$ vendor/bin/codecept run`

Некоторые тесты не будут пройдены, т.к. я намеренно удалил папку **tests** из **restful**

## Что было сделано в проекте
+ За основу был взят именно advanced шаблон, поскольку надо было разделить фронт и API, чтобы они были на разных URL.
+ Придерживался принципа, что тестовые задания существуют не столько для выполнения задания, сколько для проверки навыков и знаний. Поэтому много чего добавил, чего ТЗ не требовало.
+ Управление для администратора сделано во фронте, а не бэке, т.к. не хотел плодить лишние папки. В реальных условиях конечно же управление ушло бы в бэк.
+ Использован модуль RBAC без тюнинга, т.е. не самый используемый типа mdmsoft. Делалось это сознательно, поскольку они все примерно одинаковые, а лишние навороты в проекте ни к чему.
+ В проекте сделана подготовка под интернационализацию.
+ Поля в БД **created_at** и **updated_at** в виде Timestamp переделаны в человекоподобную дату. Считаю использование Timestamp насилием над разработчиками, т.к. при активной работе с БД и необходимости сравнения дат, Timestamp приходится постоянно конвертировать.
+ В таблице **country** все данные капсом не потому что люблю его, а потому, что взял этот дамп из интернета в целях экономии времени.
+ CRUD сделана по принципу "чтобы было удобно пользоваться": все связанные данные выводятся для человека (напр, не ID, а имя из связанной таблицы), дата не в формате DATE, а в формате, в котором ее обычно используют, и т.д.
+ Только пользователь с ролью superadmin может управлять RBAC и остальными страницами через интерфейс сайта. Клиентам доступна только стартовая и регистрация/авторизация.
+ Автора в книге я сделал в виде ID (а не фамилии под каждой книгой) сознательно, хотя считаю это плохим решением, т.к. авторы могут быть полные однофамильцы и одноименцы, но книги у них могут быть разные. Сделал именно так, чтобы показать, что обладаю навыками работы даже с двумя и более связанными таблицами.
+ Дату публикации специально сделал в виде даты, а не только год, чтобы показать свои навыки, например, вывод человекоподобной даты в таблице и поиск по этому полю в разных форматах.
+ Дополнительных тестов я не создавал, но переделал те, что идут из коробки.
+ RESTful API полностью повторяет возможности CRUD. Логика следующая: REST создается не для урезания возможностей, а для предоставления возможности удобно использовать приложения для создания своих удобных приложений. Поэтому даже URL API сделаны для понимания того, каким функционалом эти URL обладают. Например: для создания используется адрес **api.site.ru/author/create**, а не просто **api.site.ru/authors**.
+ В проекте отсутствует разделение API для администратора и клиента. Т.е. клиент, зная Endpoint URL, тоже может использовать API администратора, например, для создания авторов. Эта проблема решается использованием аутентификации. Можно было бы сделать кустарную аутентификацию с помощью cookies, но я считаю это колхозом, которому не место на проекте. Да и Postman такого жеста не поймет.
+ Прошу сделать скидку, что документация RESTful API сделана в обычном .md и с нарушениями правил написания (описание ресурса, endpoints и методы, формат запроса, ответа и т.д.). Понимаю, что для таких вещей лучше использовать не .md, а специализированные сервисы, например, Swagger.